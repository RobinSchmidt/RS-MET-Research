Just a random idea - not yet sure, if it works out - could be nonsense - have not yet worked it out.
I want to find an in-place routine for the "merge" operation in merge-sort, see:

https://en.wikipedia.org/wiki/Merge_sort
https://www.youtube.com/watch?v=J_9JsMqRwxQ


Let's assume, we have an array of 8 elements and assume the two halfs of the array are sorted and 
now we want to merge the two sorted length 4 half-arrays into one sorted length 8 array. It could 
look like this:

1 4 7 8 | 2 3 5 6

Naively, we would init pointers to index 0 and index 4 (with array-values 1 and 2), pick the 1 from 
the 1st half, then pick the 2 from the 2nd half - but that 2 would overwrite the 4 if we assume our 
target writing array to be the same as the source 2-halfs array. So what if instead of just 
overwriting the 4 with the 2, we swap the 4 with the 2 and keep track of how many values we have 
swapped during the process? We would conceptually deal with 3 arrays: input 1, input 2 and 
swap-space where the swap space coul occupy a portion of input 2. At each step, we would do:

-Check if first elem of swap-space is less than first elem of the (remaining) input 2.
 If so:
   -Swap element at write index with 1st elem of swap-space
 Else:
   Check if 1st elem of remaining input 2 is less than 1st elem of remaining input 1.
   If so:
     -Store first elem of input 2 in tmp
     -Copy first elem of input 1 into end of swap-space (increases used swap space by 1)
	 -Copy tmp into write position
   Else
     -No op: The first elem of remaining input 1 stays in its place - it's the min of all 3
	 
	 
...maybe try to implement a prototype:

rsMergeInPlace(std::vector<int>& v, int splitPoint)

in the example, the length of v would be 8 and splitPoint = 4