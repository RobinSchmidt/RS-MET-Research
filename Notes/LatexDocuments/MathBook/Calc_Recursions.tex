\section{Infinite Anythings}
After having seen infinite sums and infinite products, we'll now do a thing that mathematicians love to do: Generalize. We have defined an infinite sum via a limit over the partial sums $s_n$. The computation of such an $s_n$ was a finite sum which we already knew how to do. There is, however, another way to look at it. The computation of $s_n$ can also be seen as a formula involving the previous sum $s_{n-1}$ plus some new "update" or "correction" term $a_n$, i.e. $s_n = s_{n-1} + a_n$. For this $a_n$ term, we typically had an explicit formula involving $n$, i.e. $a_n = f(n)$ for a given function $f(n)$. With infinite products, the situation was similar with the only difference that we had a sequence of (finite) products $p_n$ and the update rule was $p_{n+1} = p_n \cdot a_n$. The general pattern here is that we compute the next term in our sequence (of partial sums or products) via some rule that takes in one (or, more generally, more) previous values of the sequence and possibly the index $n$ and computes the next value in this sequence. That is: we are dealing with sequences that can be produced via some recursive rule. ...TBC...

%===================================================================================================
\subsection{Recursively Defined Sequences}

% Maybe start with the Babylonian algorithm applied to 2 as motivating example - without yet mentioning the name.

\paragraph{Computing Square Roots}
As a motivating example, consider the following rule to compute a new term in a sequence from a previous one:
\begin{equation}
a_{n+1} = \frac{1}{2} \left( a_n + \frac{c}{a_n}  \right)
\end{equation}
For some given constant number $c$ and some given initial value $a_0$. Let's see what this rule produces for $c = 2, a_0 = 5$. The following snippet of SageMath code:
\begin{verbatim}
c = 2.0
a = 5.0
for i in range(1,9):
    a = (a + c/a) / 2
    print(a)
\end{verbatim}
produces this result:
\begin{verbatim}
2.70000000000000
1.72037037037037
1.44145536817765
1.41447098136777
1.41421358579688
1.41421356237310
1.41421356237309
1.41421356237309
\end{verbatim}
After the 8th iteration, the sequence has converged to a value that will thereafter remain the same in the first 15 decimal digits. The value that this sequence converges to is none other than the square root of two. More generally, for any given $c$, the sequence of numbers defined by this algorithm will converge to $\sqrt{c}$ regardless of the initial value $a_0$ as long as it is positive. Let's try to figure out why ...TBC...



%The explanation why should be deferred to the discussion of Newton-Raphson iteration - or maybe provide a geometric explanation here. Start with a rectangle of sidelengths 1 and c...see Weitz' video




%---------------------------------------------------------------------------------------------------
\subsubsection{Convergence}

%---------------------------------------------------------------------------------------------------
\subsubsection{Fibonacci Numbers}

% the sequence itself diverges but the sequence of ratios of successive terms converges to the golden ratio

% Maybe mention also Lucas numbers - they use the same ruel with different initial values.

\paragraph{The Golden Ratio}
Although the sequence of Fibonacci numbers itself diverges to infinity, we can construct a new sequence from it that does converge - and it does so to a rather interesting number. ...TBC...


%---------------------------------------------------------------------------------------------------
\subsubsection{Newton-Raphson Iteration}

\paragraph{The Babylonian Algorithm}

% https://en.wikipedia.org/wiki/Square_root_algorithms#Heron's_method

%---------------------------------------------------------------------------------------------------
\subsubsection{The Arithmetic-Geometric Mean}


% Frame this in the following way: we start with a vector-valued recursion formula:
% (a_{n+1}, b_{n+1}) = ((a_n + b_n)/2, sqrt{a_n b_n})
% but this can be reformulated within a framework of scalar-valued sequences by just "zipping" the a_n, b_n sequences into a single sequence. The update rule may then be of the form a_{n+1} = ...for n even, ....for n odd - or something like that. It may be inconvenient but it can be done.


%---------------------------------------------------------------------------------------------------
\subsubsection{Iterated Function Systems}

% https://en.wikipedia.org/wiki/Iterated_function_system

% Iterated Function Systems: A Comprehensive Survey
% https://arxiv.org/abs/2211.14661

% IMPLEMENTING ITERATED FUNCTION SYSTEMS IN PYTHON
% https://www.math.uni-rostock.de/~wj/projects/Fractals/160355141_Habib_Wahab_MTH6138_IFS.pdf

%===================================================================================================
\subsection{Continued Fractions}

% ...hmm...I'm not so sure if continued fractions and radicals fit in here because the upate rule actually is not so  imple. We have to evaluate the whole expression from the inside out implying that we must do a complete re-evalutation of everything for each new $n$. However, in the beginning we said that the update rule may involve more than one previous values, so maybe we can us that as justification? ..But hey! We are actually "outside" the recursion subsection here - so we do not need the content to fit in!


%===================================================================================================
\subsection{Infinite Radicals}






\begin{comment}

Maybe make a section about continued fractions. See:

Die geheime Macht der Kettenbrüche für unmögliche Gleichungen
https://www.youtube.com/watch?v=2qTgi4nq9TA


...what about infinte radicals? Or generally infinitely nested functions? Maybe take the 
arithmetic/geometric mean as example. The general theme is to have some (possibly recursive) rule to
create an infinite sequence of numbers that converges to some specific number. In series and
products, the rule is defined via a summation or product respectively. Maybe make a section "Other Infinite Sequences" or "...Computations". Maybe explain also the Newton iteration there. Maybe first
frame sums and product in terms of recursion, i.e. S_{n+1} = S_n + f(n) or something like that and products similarly. Another example is the Fibonacci sequence - and the quotient of successive terms (which converges to the golden ratio) - it also domenostrates something lese: take an existing sequence (here the Fibonacci numbers) and create a new sequence from it (here the ratios of successive terms)

-we will come full circle back to sequences - an earlier section of calculus

But maybe that's a topic for discrete calc - in the theory of recurrence relations


\end{comment}