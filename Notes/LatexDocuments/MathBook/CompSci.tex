\chapter{Computer Science}

%###################################################################################################
\section{Algorithms}


% https://en.wikipedia.org/wiki/Algorithm

% Was sind Algorithmen?
% https://www.youtube.com/watch?v=i_Zb43TEOAc  by Weitz
% -algorithm: sequence of instructions to perform a given task / solve a given problem
%  -typically has an input and an output
% -term goes back to al Khwarizmi
%  https://en.wikipedia.org/wiki/Al-Khwarizmi
% -Euclidean algo is the 1st "interesting" example of a mathematical algorithm (what about
%  the Babylonian algorithm for square roots?). Eulcid's algo dates back to 500 BC or 2500 BC?

% -typical ingredients: variable assignemnts, loops/repetition, branches/conditionals (also
%  for deciding when to stop a loop), functions/recursion (-> call stack) -
%  for convenience...although recursion might be  essential? ...we can actually get away without
%  loops if we have recursion.
% -essential ingredients: conditonal jumps (can do loops and functions, too), variable assignment 
%  (-> memory access)

% examples: sort, find, match(strings), find shortest path

% Turing's ingredients of an algorithm:
% -input
% -atomic steps that are well defined (no room for (mis)interpretation)
% -it must be possible to take steps conditionally
% -it muts be possible to repeat parts of the algorithm
% -output



% Computer sind zu dumm für Tetris oder: Die Rolle der Intuition in der Mathematik
% https://www.youtube.com/watch?v=BW2PFQz85Do

% Das 'RAM'-Modell und worst-case-Analyse
% https://www.youtube.com/watch?v=Zm91c8Xypmg

% Algorithms   by VarPi
% https://www.youtube.com/playlist?list=PL22aiDTI7A64U30SRrElmcRLfGpEmtlZE

%###################################################################################################
\section{Data Structures}

% -we said that an algotrithm takes and input and produces an output. In what form are inputs 
%  and outputs represented? could be numbers, arrays graphs, trees, a yes/no answer, etc.
% -Euclid: N x N -> N, Babylon-sqrt: R -> R, sort: array -> array, find: array -> N, 
%  prime-test: N -> bool, ...
% -in general, the inputs and outputs are data structures
% -arrays, linked lists, trees, graphs, relational data bases

%###################################################################################################
\section{Formal Languages}





%\subsubsection{Programming Languages}

% https://www.youtube.com/watch?v=UiREgHIkuiA  Die Programmiersprache TOLL
% https://www.youtube.com/watch?v=M6xP0LmVxjU  Einführung in die Programmiersprache TOLL

% https://www.youtube.com/watch?v=Xe48ZVf71jo  Die einfachste Programmiersprache der Welt: FRACTRAN 


% https://en.wikipedia.org/wiki/Structured_program_theorem

% GOTO considered awesome
% https://www.youtube.com/watch?v=1UKVEUGEk6Y

%###################################################################################################
\section{Theory of Computation}


% https://en.wikipedia.org/wiki/Primitive_recursive_function
% https://en.wikipedia.org/wiki/General_recursive_function
% https://en.wikipedia.org/wiki/Computable_function
% https://en.wikipedia.org/wiki/Double_recursion

%===================================================================================================
\subsection{Finite State Machines}

%===================================================================================================
\subsection{Turing Machines}

% https://en.wikipedia.org/wiki/Turing_machine
% Busy Beavers

% The Device That Defined a “Computer”
% https://www.youtube.com/watch?v=d75o8AODPvI

% https://www.youtube.com/watch?v=8zFv1RWe1OM  Die Church-Turing-These (Theoretische Informatik)

%===================================================================================================
\subsection{Lambda Calculus}

%===================================================================================================
\subsection{Random Access Machines}


% The Boundary of Computation
% https://www.youtube.com/watch?v=kmAc1nDizu0

%###################################################################################################
\section{Complexity Theory}

% NP-Completness


% Superpolynomial & Subexponential?
% https://www.youtube.com/shorts/vfrzHvXsG0E


%###################################################################################################
\section{Artificial Intelligence}




% Machine Learning For Physicists (Course)
% https://www.youtube.com/watch?v=iqVeZ70muyw&list=PL0iK4i3eaebb7ilRL9oGMyiowFwym0SHf


%###################################################################################################
\section{Quantum Computing}


% Quantum Computation and Algorithms   by VarPi
% https://www.youtube.com/playlist?list=PL22aiDTI7A65Pk54Bl86O9-q5oGxy7Fny


\begin{comment}

Programming/Algorithms: 
-Turing completeness, Turing-machine, random-access-machine
 Super turing machines: https://en.wikipedia.org/wiki/Hypercomputation

https://en.wikipedia.org/wiki/Chaitin%27s_constant


https://www.youtube.com/watch?v=yi4Ho_K5LRw  What is Primitive Recursion?
https://www.youtube.com/watch?v=_NwZh-0X9tQ  Limitations of Primitive Recursive Functions


How to solve Hard Problems by Guessing | Algorithmic Intuition #1
https://www.youtube.com/watch?v=W8xj4ybqiik
-I think, the general idea is: You can solve a problem in O(n*log(n)) time if you can check in O(n)
 time (for example, by a greedy algorithm), if a guessed solution is either too large to be a lower 
 bound or too small to be an upper bound? If that is possible and you can come up with an initial 
 lower and upper bound (in the case of the video: 0 and sum a_i), then you can use bisection (or 
 binary search) to narrow down the interval where the true solution must be until you have only one
 value left - which then is the solution.


Effiziente Algorithmen CS566 (Winter 2024-25)
https://www.youtube.com/playlist?list=PLzL0t_-LZiYljCHd_NcsDBbn2LfhOKRtK


Every Computer Science College Course Explained in 12 Minutes
https://www.youtube.com/watch?v=Ob7fjjUieko


The Heisenberg "Principle" of Machine Learning | ML for Physicists Ep. 5
https://www.youtube.com/watch?v=FbFZQUw52b4
-About decomposing the mean squared error (MSE) into bias and variance: MSE = bias^2 + variance


How a Leap of Faith Solved an Impossible Problem | #SoME4
https://www.youtube.com/watch?v=U03AiaWJfb8
-About the Ising problem. It's a physical problem that turns out to be equivalent to a lot of other
 computational problems in the sense that you can map these problems from/to the Ising problem. 
 These include: traveling salesman, max-cut, number partitioning, k-SAT


The Future of Math is Programming
https://www.youtube.com/watch?v=QXQNet2yTdk
-Explains how proof-checkers like LEAN work.

these compression algorithms could halve our image file sizes (but we don't use them) #SoMEpi
https://www.youtube.com/watch?v=RFWJM8JMXBs


Math vs Code: 10 Concepts That Are Basically the Same! (With C++ Examples)
https://www.youtube.com/watch?v=ZKIH5B5Hn9E
-Others: naturals: unsigned int, integers: signed int, reals: float/double, rational: class, 
 complex: class, vectors,matrices,tensors,etc.: classes
-operators: +,-,*,/ - direct mapping.
-equality-check: ==, comparisons: <,<=,>,>=
-equality-by-definition: = (assignment)
-sequences: arrays (finite), generators (infinite)
-sets: std::set (for typed sets - it's a somewhat different concept than sets in math)


The HoTTest Axiom of math
https://www.youtube.com/watch?v=h2H5MF8Ebh0
-about type theory



Why Don't We Program In Lambda Calculus? Rust, Lisp, and Church's Thesis
https://www.youtube.com/watch?v=29HiMdpTn10

The Curves that Break Encryption
https://www.youtube.com/watch?v=ihBWwjVDnEk


Is the number omega a mathematical oracle?
https://www.youtube.com/watch?v=rLjTMUKJ-vQ


Type theory and the algebra of types    by All Angles
https://www.youtube.com/watch?v=6hAeJmKXRfo
-A type is a set of values with an associated set of operations that can be applied to these values.
-Sum types contain a value from one type A or another type B. 
-Product types contain a value from one type A and another type B.
-Exponential types contain all functions from one type A to another type B.

Non-numerical processing tasks:
-Lists: sort, search, permute according to criteria, find all permutations in order, check if
 one list is permutation of another,
-Strings: compare lexicogragpically, find substring, regex match, similarity (e.g. levenshtein
 distance)
-Graphs: find path, find all paths, find shortest path, find (shortest) Eulerian path, ...
-Logic: SAT-solver
-Sets: find element, has_subset, is_transitive



\end{comment}