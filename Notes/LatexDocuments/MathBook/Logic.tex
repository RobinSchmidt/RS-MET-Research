\chapter{Logic}


%===================================================================================================
\section{Propositional Logic}
Propositional logic deals with statements that can be either true or false. These statements are called propositions. The propositions are typically represented by variable symbols such as $p$ and $q$. For example, a proposition could be defined as $p = \text{"It is hot outside"}$ and another one could be $q = \text{"Chocolate melts in the heat"}$ and yet another one could be $r = \text{"The chocolate is outside"}$ and a last one could be $s = \text{"The chocolate is melting"}$. Propositional logic is concerned with formalizing processes like concluding $s$ from $p,q,r$. The machinery is the set of multivariate functions from the set $\{0,1\}$ to itself. So, $0$ and $1$ are the two possible values that our variables like $p,q,\ldots$ can take on and we interpret $1$ as "the proposition is true" and $0$ as "the proposition is false". We plug them in into a function and it spits out a value which is also either $0$ or $1$. We'll denote the set $\{0,1\}$ as $\mathbb{B}$ in honor to George Boole\footnote{George Boole: English mathematician, 1815-1864, Inventor of Boolean algebra}. We are concerned with functions $f$ of the type $f: \mathbb{B}^n \rightarrow \mathbb{B}$. We'll typically build such multivariate Boolean functions from a couple of basic bivariate Boolean functions of the type $f: \mathbb{B} \times \mathbb{B} \rightarrow \mathbb{B}$ and possibly the only nontrivial univariate Boolean function, namely the negation which maps $0$ to $1$ and $1$ to $0$. Propositional logic is also known as \emph{zeroth order logic} indicating that there is a hierarchy of logical systems with various levels. Indeed, one level up, we'll find predicate logic which is also known as first order logic. ...TBC...

%  Propositional logic is the foundation of all higher order

% https://en.wikipedia.org/wiki/Boolean_algebra

\subsection{Connectives}
Logical connectives are symbols that are used to create more complex logical expressions from simpler ones. They work with logical variables like the basic arithmetic operators do with numerical variables. They typically take two inputs and produce one output\footnote{The only exception is the negation which takes only a single input. It's somewhat analogous to the unary minus in arithmetic.}. Like arithmetic operators, we write them in infix notation between the variables. A non-exhaustive table of such connectives is given here:

\medskip
\begin{tabular}{c l l}
\label{Tab:LogicConnectives}
  Symbol           & Name                  & Meaning      \\
  $\neg p$         & Negation              & not $p$       \\
  $p \wedge q$     & Conjunction           & $p$ and $q$    \\
  $p \vee q$       & Disjunction           & $p$ or $q$ (maybe both)   \\
  $p \then q$      & Material Implication  & $p$ implies $q$, if $p$ then $q$   \\  
  $p \mequiv q$    & Material Equivalence  & $p$ if and only if $q$, $p$ iff $q$   \\    
  $p \xor q$       & Exclusive or, Xor     & either $p$ or $q$, $p$ or $q$ but not both   \\ 
  $p \nand q$      & Non-Conjunction, Nand & Not both, Not ($p$ and $q$)   \\   
\end{tabular}
\medskip

As said, the list is not exhaustive. There are 16 possible different functions $f: \mathbb{B}^2 \rightarrow \mathbb{B}$ and we have listed only the $6$ most commonly used ones of them. We do not need a symbol for all of them because we can construct the missing ones from those in the table. In fact, we don't even need all of the connectives given in the table. A set of connectives from which all possible Boolean functions can be constructed by a suitable formula is called a \emph{functionally complete} set of connectives. For example, the set $\{\neg, \wedge, \vee\}$ is functionally complete. It is actually even overcomplete already and we could make do with  $\{\neg, \wedge\}$ but having the $\vee$ available as well makes it more convenient to write down and read(!) logical formulas. As an extreme example, the singleton set containing only the nand function $\nand$ is also functionally complete. It's not fun to read or write logical formulas when only the nand operator is permitted - but it is possible to express every possible logical formula solely in terms of nand. This fact has some technological relevance in the realm of chip design.

...TBC..TODO: give truth tables for all of them, explain relation between $\then$ and $\Rightarrow$ and $\mequiv$ and $\Leftrightarrow$. The double-stroke arrow symbols are used on the meta level whereas the single-stroke arrows are used on the object level or formula level. Give other names for the connectives - there are a lot of akas

% https://en.wikipedia.org/wiki/Functional_completeness
% https://en.wikipedia.org/wiki/Sheffer_stroke  aka nand
% https://en.wikipedia.org/wiki/Exclusive_or
% https://en.wikipedia.org/wiki/Logical_connective
% https://en.wikipedia.org/wiki/Logical_equivalence#Relation_to_material_equivalence
% https://en.wikiversity.org/wiki/Logical_implication
% https://en.wikipedia.org/wiki/Logical_biconditional
% -explain difference between material conditional and logical implication
% -explain difference between material equivalence and logical equivalence/biconditional
%  material biconditional or equivalence or biimplication or bientailmen

% What about constant functions that always output 0 or 1

%===================================================================================================
\section{Predicate Logic}


%\subsection{Notation}

\subsection{Quantifiers}

$\exists, \nexists, \exists!, \exists_1, \forall$

% -also known as first order logic
% -Variables, Formulas
% -Quantors: \exists, \forall, \exists ! (it exists exactly one)

% https://en.wikipedia.org/wiki/Quantifier_(logic)
% https://de.wikipedia.org/wiki/Quantor

%===================================================================================================
\section{Proof Techniques}


% https://jdhsmith.math.iastate.edu/class/BookOfProof.pdf
% -Really good free ebook

%---------------------------------------------------------------------------------------------------
\subsection{Deduction}
Logical \emph{deduction} is the process of deriving new true statements from given true statements. In this context, the given statements are called \emph{premises} and the derived statements are called \emph{conclusions}. The process of deriving new statements from known ones is called \emph{inference} and there are certain rules that we need to obey to draw valid conclusions from a given set of premises.

% https://de.wikipedia.org/wiki/Deduktion

% https://home.uni-leipzig.de/methodenportal/deduktion_induktion/
% -Deduktion schließt vom allgemeinen auf das spezielle
% -Induktion schließt vom speziellen auf das allgemeine

% https://en.wikipedia.org/wiki/Logical_consequence
% https://en.wikipedia.org/wiki/Propositional_calculus

\subsubsection{Rules of Inference}
% https://en.wikipedia.org/wiki/Rule_of_inference

\paragraph{Modus Ponens}
% https://en.wikipedia.org/wiki/Modus_ponens

\paragraph{Modus Tollens}
% https://en.wikipedia.org/wiki/Modus_tollens

\paragraph{Contraposition}
% https://en.wikipedia.org/wiki/Contraposition

\paragraph{Resolution}
% -Resolution
%  https://de.wikipedia.org/wiki/Resolution_(Logik)
% https://en.wikipedia.org/wiki/Resolution_(logic)

% https://de.wikipedia.org/wiki/Schlussregel
% https://de.wikipedia.org/wiki/Abduktion

%---------------------------------------------------------------------------------------------------
\subsection{Induction}
Proof by induction is a proof technique that can be used to prove a statement $\varphi(n)$ that should hold for any natural number $n$ greater or equal to some given $n_0$ (which is often $0$ or $1$). The technique works by first showing directly that the statement holds true for $n_0$. It then goes on by showing that whenever the statement holds for some $n$, then it automatically follows that it must also hold for $n+1$. It then follows that $\varphi(n)$ holds for any $n \geq n_0$.

\paragraph{Example: Gauss's summation formula} A well known formula for the sum over all natural numbers up to some given $n$ is $\sum_{k=1}^n k = \frac{n (n+1)}{2}$. We will use induction to prove that the formula works for every $n \in \mathbb{N}$. We need to first show it directly for $n=1$. We have $\sum_{k=1}^1 k = 1$ and we have $\frac{1 (1+1)}{2} = 1$, so the formula works for $n=1$. ...TBC...

% https://en.wikipedia.org/wiki/Mathematical_induction




%===================================================================================================
\section{Higher Order Logic}
Propositional logic and predicate logic is also called zeroth and first order logic respectively indicating a hierarchy of logical systems. The position in this hierarchy determined by what the variables that appear in the formulas stand for. That is formalized in the idea of the \emph{domain of discourse} which is the universe of things that we can talk about.

\medskip
In 0th order logic, i.e. propositional logic, the variables just stand for truth values. That means, any variable $x$ that appears in a formula can be assigned either true or false and that's it. Variables have no inner structure. Our domain of discourse is just the relation between logical formulas themselves - like is one formula equivalent to another, does one imply the other, etc. We cannot yet talk about objects from the world, so to speak. ...TBC...

%For example, the formula $(x \rightarrow y) \wedge x$ implies the much simpler formula $y$.

\medskip
In 1st order logic, the variables that were formerly just atomic truth values now become predicates over real world objects like numbers, sets, set elements, etc. We can now express things like "There exists a number such that...". We use quantifiers like $\exists$ and $\forall$ to introduce a variable. ...TBC...

\medskip
In 2nd order logic, we can additionally quantify over predicates. For example, we could write down the law of the excluded middle as: $\forall \varphi \forall x: (\varphi(x) \vee \neg \varphi(x))$. The formula says that for any predicate $\varphi$ and for any variable $x$, either $\varphi(x)$ or $\neg \varphi(x)$ is true\footnote{Shouldn't the law use an exclusive or, i.e. say $\varphi(x) \xor \neg \varphi(x)$? I mean, the use of inclusive or does not render the statement wrong (in fact, it turns it into a tautology) - but it doesn't seem to express that $\varphi$ and $\neg \varphi$ are mutually exclusive which is clearly the intended meaning when calling it law of the \emph{excluded} middle. Figure out!}.

% -bound variables

%we get variables that stand for sets or set elements and we can quantify over such variables by means of quantifiers like $\exists$ and $\forall$.

% Propositional logic deal with propositions and the relations between them. 




% https://en.wikipedia.org/wiki/Atomic_formula
% https://en.wikipedia.org/wiki/Propositional_variable

% https://en.wikipedia.org/wiki/Domain_of_discourse

% https://en.wikipedia.org/wiki/Propositional_calculus

% https://en.wikipedia.org/wiki/First-order_logic
%  In propositional logic, these sentences themselves are viewed as the individuals of study, and might be denoted, for example, by variables such as p and q. They are not viewed as an application of a predicate

%https://en.wikipedia.org/wiki/Second-order_logic
% First-order logic quantifies only variables that range over individuals (elements of the domain of discourse); second-order logic, in addition, quantifies over relations.

%https://en.wikipedia.org/wiki/Higher-order_logic
%https://en.wikipedia.org/wiki/Type_theory

%===================================================================================================
\section{Other Logical Systems}

\subsection{Modal Logic}
% https://en.wikipedia.org/wiki/Modal_logic

\subsection{Temporal Logic}
% https://en.wikipedia.org/wiki/Temporal_logic

\subsection{Three Valued Logic}
% https://en.wikipedia.org/wiki/Many-valued_logic

\subsection{Fuzzy Logic}
% https://en.wikipedia.org/wiki/Fuzzy_logic


\begin{comment}

% For the logic chapter that should come before this chapter:
%\begin{eqnarray}
%\forall x : \varphi(x) \Leftrightarrow \neg \exists x : \neg \varphi(x) \\
%\exists x : \varphi(x) \Leftrightarrow \neg \forall x : \neg \varphi(x)
%\end{eqnarray}
% Equations between quantors

% https://en.wikipedia.org/wiki/Theory_(mathematical_logic)#First-order_theories
% https://en.wikipedia.org/wiki/Method_of_analytic_tableaux
% https://en.wikipedia.org/wiki/Resolution_(logic)
% https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem
% https://en.wikipedia.org/wiki/List_of_first-order_theories

https://en.wikipedia.org/wiki/Model_theory


https://en.wikiversity.org/wiki/Logical_implication
https://simple.wikipedia.org/wiki/Implication_(logic)
https://en.wikipedia.org/wiki/Material_conditional

https://en.wikipedia.org/wiki/Logical_consequence

https://en.wikipedia.org/wiki/Modal_logic

\end{comment}